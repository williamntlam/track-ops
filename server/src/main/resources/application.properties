spring.application.name=server

# Database Configuration (local development)
spring.datasource.url=jdbc:postgresql://localhost:5432/trackops_orders
spring.datasource.username=postgres
spring.datasource.password=password
spring.datasource.driver-class-name=org.postgresql.Driver

# Flyway (runs on startup; schema versioning)
spring.flyway.enabled=true
spring.flyway.baseline-on-migrate=true

# JPA/Hibernate: validate only (schema managed by Flyway)
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true

# Redis Configuration
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.timeout=2000ms
spring.redis.database=0

# Kafka Configuration
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=trackops-orders
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer

# Schema Registry Configuration
schema.registry.url=http://localhost:8081
schema.registry.basic.auth.user.info=${SCHEMA_REGISTRY_BASIC_AUTH_USER_INFO:}
schema.registry.cache.capacity=1000
schema.registry.auto.register.schemas=true
schema.registry.compatibility.level=BACKWARD

# Server Configuration
server.port=8081

# Health Check Configuration
management.endpoints.web.exposure.include=health,info,metrics,prometheus,caches
management.endpoint.health.show-details=always
management.endpoint.health.show-components=always
management.endpoint.caches.enabled=true
management.health.defaults.enabled=true
management.health.db.enabled=true
management.health.redis.enabled=true
management.health.diskspace.enabled=true
management.health.diskspace.threshold=100MB
management.info.env.enabled=true
management.info.java.enabled=true
management.info.build.enabled=true
management.metrics.export.prometheus.enabled=true
management.metrics.tags.application=trackops-server
management.metrics.tags.environment=${SPRING_PROFILES_ACTIVE:default}
management.metrics.distribution.percentiles-histogram.http.server.requests=true
management.metrics.distribution.percentiles.http.server.requests=0.5,0.95,0.99
management.metrics.distribution.sla.http.server.requests=10ms,50ms,100ms,200ms,500ms,1s,2s,5s
management.metrics.cache.enabled=true

# Logging Configuration
logging.config=classpath:logback-spring.xml
logging.level.com.trackops.server=INFO
logging.level.org.springframework=WARN
logging.level.org.springframework.web=WARN
logging.level.org.springframework.security=WARN
logging.level.org.springframework.kafka=WARN
logging.level.org.springframework.data=WARN
logging.level.org.hibernate=WARN
logging.level.org.apache.kafka=WARN
logging.level.io.lettuce=WARN
logging.level.com.zaxxer.hikari=WARN

# Log Path Configuration
LOG_PATH=logs
APP_VERSION=1.0.0

# Event Publishing Strategy Configuration
# Options: 'outbox' (default) or 'debezium'
app.event-publishing.strategy=debezium

# DLQ Configuration (PostgreSQL dlq_orders table for failed order events)
app.dlq.max-retries=3

# DLQ consumer throttling (pause ingestion when DLQ grows to protect DB)
app.dlq.throttle.enabled=true
app.dlq.throttle.high-watermark=50000
app.dlq.throttle.low-watermark=10000
app.dlq.throttle.check-interval-ms=60000

# Debezium Configuration (only used when strategy=debezium)
app.debezium.enabled=true
app.debezium.connector-url=http://localhost:8083/connectors
app.debezium.topics.orders=trackops_orders.public.orders
app.debezium.topics.order-items=trackops_orders.public.order_items

# Redis Cache Configuration
app.cache.ttl.order=3600
app.cache.ttl.status=1800
app.cache.ttl.response=1800
app.cache.ttl.customer=3600
app.cache.ttl.page=900
# Additive TTL jitter (seconds): each key gets base TTL + random(0, jitter) so expirations are spread
app.cache.ttl.jitter-seconds=300
# Probabilistic early revalidation: randomly refresh entries near expiry (spreads load)
app.cache.probabilistic-refresh.enabled=true
app.cache.probabilistic-refresh.window-ratio=0.2
# Sweep: scan all cached order keys and probabilistically refresh (scalable, traffic-independent)
app.cache.probabilistic-refresh.sweep-enabled=true
app.cache.probabilistic-refresh.sweep-interval-ms=300000
app.cache.probabilistic-refresh.sweep-max-keys-per-run=500
app.cache.warming.enabled=true
app.cache.invalidation.enabled=true
# Pre-warm: number of most recently updated orders to load into Redis on startup
app.cache.prewarm.size=1000
# Distributed lock for cache load (stampeding protection)
app.cache.load-lock.wait-seconds=10
app.cache.load-lock.lease-seconds=30

# Resilience4j Circuit Breaker (downstream Kafka / inventory events)
resilience4j.circuitbreaker.instances.downstreamKafka.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.downstreamKafka.wait-duration-in-open-state=30s
resilience4j.circuitbreaker.instances.downstreamKafka.sliding-window-size=10
resilience4j.circuitbreaker.instances.downstreamKafka.minimum-number-of-calls=5

# Rate Limiting Configuration
app.rate-limit.enabled=true
app.rate-limit.default-requests-per-hour=1000
app.rate-limit.burst-capacity=100
